#include "smmap/diminishing_rigidity_model.h"

#include <stdexcept>
#include <limits>

using namespace smmap;

////////////////////////////////////////////////////////////////////////////////
/// Constructors and Destructor
////////////////////////////////////////////////////////////////////////////////

DiminishingRigidityModel::DiminishingRigidityModel
    ( ObjectPointSetPtr starting_points_, double k_translation_ )
    : DiminishingRigidityModel( starting_points_, k_translation_, k_translation_ )
{}

DiminishingRigidityModel::DiminishingRigidityModel
    ( ObjectPointSetPtr starting_points_, double k_translation_, double k_rotation_ )
    : starting_points( starting_points_ )
    , k_translation( k_translation_ )
    , k_rotation ( k_rotation_ )
{
    if ( k_translation <= 0 )
    {
        throw new std::invalid_argument("k_translation must be greater than 0");
    }
    if ( k_rotation <= 0 )
    {
        throw new std::invalid_argument("k_rotation must be greater than 0");
    }
}

////////////////////////////////////////////////////////////////////////////////
/// Static member initialization
////////////////////////////////////////////////////////////////////////////////

/// TODO: remove this magic number for the noise generated by this distribution
std::normal_distribution< double > DiminishingRigidityModel::perturbation_distribution =
    std::normal_distribution< double >( 0, 0.1 );

////////////////////////////////////////////////////////////////////////////////
/// Virtual function overrides
////////////////////////////////////////////////////////////////////////////////

ObjectTrajectory DiminishingRigidityModel::doGetPrediction(
        const GripperTrajectory &gripper_traj_ ) const
{
    ObjectTrajectory object_traj( gripper_traj_.size(), *starting_points );
    return object_traj;
}

void DiminishingRigidityModel::doPerturbModel(
        const std::shared_ptr< std::mt19937_64 >& generator )
{
    k_translation += perturbation_distribution( *generator );
    k_rotation += perturbation_distribution( *generator );

    if ( k_translation <= 0 )
    {
        k_translation = std::numeric_limits< double >::epsilon();
    }
    if ( k_rotation <= 0 )
    {
        k_rotation = std::numeric_limits< double >::epsilon();
    }
}
